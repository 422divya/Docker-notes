==> If we want to set up complex application running multiple services a better way is to user docker compose
==> With Docker compose we can create configuration file in YAML format called docker-compose.yaml and put together different services and options specific to this running them
in this file and then run "docker compose up" command to bring up the entire application stack
==> However this is all only applicable to running containers on a single Docker host

==> Example take voting app. In this we have voting-app web interface written in python, Redis in-mem DB, worker,postgresql DB, result-app.
==> We can use docker run command to run instance of all the voting app image total 5 containers.
==> But doing this only we will not be able to access the voting-app web interface as all this containers are not linked to each other. As voting web-app service is dependent
on the redis service when web server starts
==>But voting container host cannot resolve host by name Redis.
==> To make aware of the Redis service we add a link option while running voting app container to  link it to redis container.

# docker run -d --name=vote -p 5000:80 --link redis:redis voting-app

name-of-container:name-of-host: both ae redis
=============================================

==> What link does is it creates an entry in /etc/hosts file on vote app container adding hostname redis with internal ip of redis container.
==> Using link this way is deprecated and can be removed in future

docker-compose.yml

version: 1   >> docker compose version
services:
redis:
 image: redis
db:
 image: postgresql:9.4
vote:
 image: voting-app
 ports:
  - 5000:80
 links:
  - redis
result:
 image: result-app
 ports:
  -5001:80
 links:
  - db

In new version of docker compose we dont need to use links as Docker compose automatically creates a dedicated bridge network for this application anf then attaches all containers
to that new network. All containers are then able to communicate to each other using each other service name. So no need to use links

docker-compose.yml

version: "2"   >> docker compose version
services:
redis:
 image: redis
db:
 image: postgresql:9.4
vote:
 image: voting-app
 ports:
  - 5000:80

result:
 image: result-app
 ports:
  -5001:80
